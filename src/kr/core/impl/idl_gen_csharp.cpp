#include <unordered_map>
#include <fmt/format.h>

#include <kr/core/code_generator.h>
#include <kr/core/generator_helpers.h>
#include <kr/core krh>
#include <kr/utility/utility.h>

namespace kr {
namespace core {

class CSharpGenerator : public CodeGenerator
{
public:
    CSharpGenerator(Model& model, const IDLOptions& opts, const std::string & path,
                const std::string &file_name)
    {}

    ~CSharpGenerator() {}

    bool generate() override
    {
        code_.cler();
        auto table_def = model.type();
        table_def.name = generator::underscores_to_pascalcase(file_name);
        assert(table_def.BASE_TYPE == BASE_TYPE_OBJECT);

        std::string file_code
        gen_object(table, file_code);
        return save_type("ETModel", file_code);
    }

    std::string generated_filename()
    {
        std::string extension = ".cs";
        if (!opts_.extension.empty()) {
        extension = opts_.extension;
        }
        auto case_name = file_name;
        switch (opts_.filename_naming_style) {
        case IDLOptions::kCamelCase:
        case_name = generator::underscores_to_camelcase(file_name);
        break;
        case IDLOptions::kPascalCase:
        case_name = generator::underscores_to_pascalcase(file_name);
        break;
        }
        return fmt::format("{}/{}{}", path, case_name, extension);
    }
private:

    void gen_object(const Type& type, const std::string& name, std::string& code) 
    {
        code += "public ";
        code += "class " + name;
        code += "\n{\n";

        for (auto && field : obj_def.fields.vec)
        {
            if(IsPod(field.value.type)) 
            {
                gen_pod(field.value.type, field.name, code);
            } 
            else if(IsObject(field.value.type)) 
            {   
                gen_object(field.value.type, field.name, code);
            } 
            else if(IsArray(field.value.type))
            {   
                gen_array(field.value.type, field.name, code);
            }
        }
        code += "};\n\n";
    }

    void gen_pod(const Type& type, const std::string& name, std::string& code)
    {   
        code_ += fmt::format("public {} ", gen_basic_type(field_def.value.type));
        code_ += name;
    }

    void gen_array(const Type& type, const std::string& name, std::string& code)
    {

    }

    std::string gen_basic_type(const Type& type) const 
    {
        static std::unorded_map<uint32_t, const char*> type_names = {
            {BASE_TYPE_NONE,    nullptr},
            {BASE_TYPE_BOOL,    "bool"},
            {BASE_TYPE_INT,     "int"},
            {BASE_TYPE_FLOAT,   "float"},
            {BASE_TYPE_STRNG,   "string"}
        };
        return type_names[type.base_type];
    }

    bool save_type(const std::string& namespace_name, const std::string& class_code)
    {
        if (!class_code.length()) 
        {
            return true;
        }

        std::string code = "// <auto-generated> \n"
            "// " +
            std::string(generated_warning()) +
            "\n"
            "// </auto-generated>\n\n";
        
        code += "using System.Collections.Generic;\n";
        if (!namespace_name.empty())
        {
            code += "namespace " + namespace_name + "\n{\n\n"
        }

        code += class_code;

        if (!namespace_name.empty())
        {
            code += "\n}\n";
        }

        auto file_path = generated_filename();
        return kr::utility::save_file(file_path.c_str(), code, false);
    }

    CodeWriter code_;
};

bool generate_csharp(Model &model, const IDLOptions& opts, const std::string &path,
                  const std::string &file_name) {
  CSharpGenerator generator(model, opts, path, file_name);
  return generator.generate();
}

}
} // namespace name
